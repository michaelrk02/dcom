package codegen

import (
	"encoding/json"
	"encoding/xml"
	"fmt"
	"io/fs"
	"os"
	"path/filepath"
	"regexp"

	"github.com/dave/jennifer/jen"
)

type Package struct {
	Path   string `json:"path"`
	Alias  string `json:"alias"`
	Suffix string `json:"suffix"`
}

type Blueprint struct {
	InventoryDir     string  `json:"inventoryDir"`
	GeneratedDir     string  `json:"generatedDir"`
	ComponentPackage Package `json:"componentPackage"`
	ProxyPackage     Package `json:"proxyPackage"`
	StubPackage      Package `json:"stubPackage"`
}

func (bp *Blueprint) Load(fileName string) error {
	file, err := os.Open(fileName)
	if err != nil {
		return err
	}
	defer file.Close()

	err = json.NewDecoder(file).Decode(bp)
	if err != nil {
		return err
	}

	return nil
}

func (bp *Blueprint) BuildTree() (*Tree, error) {
	t := &Tree{
		Structures: []Structure{},
		Interfaces: []Interface{},
	}

	err := filepath.WalkDir(bp.InventoryDir, func(path string, d fs.DirEntry, err error) error {
		if d.IsDir() {
			return nil
		}

		if regexp.MustCompile(`\.xml$`).MatchString(d.Name()) {
			err := func() error {
				file, err := os.Open(path)
				if err != nil {
					return err
				}
				defer file.Close()

				fmt.Printf("Parsing: %s ...\n", d.Name())

				var subtree Tree

				err = xml.NewDecoder(file).Decode(&subtree)
				if err != nil {
					return err
				}

				err = bp.ParseIDL(&subtree)
				if err != nil {
					return err
				}

				t.Merge(&subtree)

				return nil
			}()
			if err != nil {
				return err
			}
		}

		return nil
	})
	if err != nil {
		return nil, err
	}

	return t, nil
}

func (bp *Blueprint) ParseIDL(tree *Tree) error {
	for k := range tree.Structures {
		st := &tree.Structures[k]

		for i := range st.Properties {
			st.Properties[i].DataType = NewDataType(st.Properties[i].Type, bp.ComponentPackage)
		}
	}

	for k := range tree.Interfaces {
		in := &tree.Interfaces[k]

		for i := range in.Properties {
			p := in.Properties[i]

			var mRead InterfaceMethod
			mRead.Name = fmt.Sprintf("Get%s", ToPascal(p.Name))
			mRead.ReturnType = p.Type
			mRead.Params = []InterfaceMethodParam{}

			var mWrite InterfaceMethod
			mWrite.Name = fmt.Sprintf("Set%s", ToPascal(p.Name))
			mWrite.Params = []InterfaceMethodParam{
				{
					Name: p.Name,
					Type: p.Type,
				},
			}

			if p.Access == "" {
				p.Access = AccessPublic
			}

			switch p.Access {
			case AccessPublic:
				mRead.Access = AccessPublic
				mWrite.Access = AccessPublic
			case AccessPrivate:
				mRead.Access = AccessPrivate
				mWrite.Access = AccessPrivate
			case AccessReadonly:
				mRead.Access = AccessPublic
				mWrite.Access = AccessPrivate
			}

			in.Methods = append(in.Methods, mRead, mWrite)
		}

		for i := range in.Methods {
			m := &in.Methods[i]

			if m.Access == "" {
				m.Access = AccessPublic
			}

			if m.ReturnType != "" {
				dt := NewDataType(m.ReturnType, bp.ComponentPackage)
				m.ReturnDataType = &dt
			}

			for j := range m.Params {
				m.Params[j].DataType = NewDataType(m.Params[j].Type, bp.ComponentPackage)
			}
		}
	}

	return nil
}

func (bp *Blueprint) Generate(gen Generator, dir, name, pkg string) error {
	err := os.MkdirAll(dir, 0777)
	file, err := os.Create(fmt.Sprintf("%s/%s.go", dir, name))
	if err != nil {
		return err
	}
	defer file.Close()

	fmt.Printf("Generating %s ...\n", name)

	f := jen.NewFile(pkg)

	f.HeaderComment("This file is automatically generated using DCOM IDL")
	f.HeaderComment("Please do not edit by hand")

	f.ImportAlias(bp.ComponentPackage.Path, bp.ComponentPackage.Alias)
	f.ImportAlias(bp.ProxyPackage.Path, bp.ProxyPackage.Alias)
	f.ImportAlias(bp.StubPackage.Path, bp.StubPackage.Alias)

	gen.Generate(f, bp)

	err = f.Render(file)
	if err != nil {
		return err
	}

	return nil
}
