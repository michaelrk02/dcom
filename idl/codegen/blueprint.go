package codegen

import (
	"encoding/json"
	"encoding/xml"
	"fmt"
	"io/fs"
	"os"
	"path/filepath"
	"regexp"

	"github.com/dave/jennifer/jen"
)

type Package struct {
	Path   string `json:"path"`
	Alias  string `json:"alias"`
	Suffix string `json:"suffix"`
}

type Blueprint struct {
	InventoryDir     string  `json:"inventoryDir"`
	GeneratedDir     string  `json:"generatedDir"`
	ComponentPackage Package `json:"componentPackage"`
	ProxyPackage     Package `json:"proxyPackage"`
	StubPackage      Package `json:"stubPackage"`
}

func (bp *Blueprint) Load(fileName string) error {
	file, err := os.Open(fileName)
	if err != nil {
		return err
	}
	defer file.Close()

	err = json.NewDecoder(file).Decode(bp)
	if err != nil {
		return err
	}

	return nil
}

func (bp *Blueprint) BuildTree() (*Tree, error) {
	t := &Tree{
		Structures: []Structure{},
		Interfaces: []Interface{},
	}

	err := filepath.WalkDir(bp.InventoryDir, func(path string, d fs.DirEntry, err error) error {
		if d.IsDir() {
			return nil
		}

		if regexp.MustCompile(`\.xml$`).MatchString(d.Name()) {
			err := func() error {
				file, err := os.Open(path)
				if err != nil {
					return err
				}
				defer file.Close()

				fmt.Printf("Parsing: %s ...\n", d.Name())

				err = xml.NewDecoder(file).Decode(t)
				if err != nil {
					return err
				}

				err = bp.ParseIDL(t)
				if err != nil {
					return err
				}

				return nil
			}()
			if err != nil {
				return err
			}
		}

		return nil
	})
	if err != nil {
		return nil, err
	}

	return t, nil
}

func (bp *Blueprint) ParseIDL(tree *Tree) error {
	for _, st := range tree.Structures {
		for i := range st.Properties {
			st.Properties[i].DataType = NewDataType(st.Properties[i].Type, bp.ComponentPackage)
		}
	}

	for _, in := range tree.Interfaces {
		for i := range in.Methods {
			if in.Methods[i].Access == "" {
				in.Methods[i].Access = AccessPublic
			}

			if in.Methods[i].ReturnType != "" {
				dt := NewDataType(in.Methods[i].ReturnType, bp.ComponentPackage)
				in.Methods[i].ReturnDataType = &dt
			}

			for j := range in.Methods[i].Params {
				in.Methods[i].Params[j].DataType = NewDataType(in.Methods[i].Params[j].Type, bp.ComponentPackage)
			}
		}
	}

	return nil
}

func (bp *Blueprint) Generate(gen Generator, dir, name, pkg string) error {
	err := os.MkdirAll(dir, 0777)
	file, err := os.Create(fmt.Sprintf("%s/%s.go", dir, name))
	if err != nil {
		return err
	}
	defer file.Close()

	fmt.Printf("Generating %s ...\n", name)

	f := jen.NewFile(pkg)

	f.HeaderComment("This file is automatically generated using DCOM IDL")
	f.HeaderComment("Please do not edit by hand")

	f.ImportAlias(bp.ComponentPackage.Path, bp.ComponentPackage.Alias)
	f.ImportAlias(bp.ProxyPackage.Path, bp.ProxyPackage.Alias)
	f.ImportAlias(bp.StubPackage.Path, bp.StubPackage.Alias)

	gen.Generate(f, bp)

	err = f.Render(file)
	if err != nil {
		return err
	}

	return nil
}
